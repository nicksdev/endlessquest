
TODO:

//Handle exceptions for taking from containers
//look (at, in, etc) - looks inside, searches etc. E.g. search dead mobs, look in chest
//have objects that cannot be picked up
//make all armour type armour and add a slot for its location.
//add inventory check function which checks the item is present in inventory
//add ability to use an item
//on 'equip' check use = equip
//usable items, e.g. potion of healing, door key
//allow the user to choose an action when in combat (defaulting to attack at the moment). Could be use, flee, etc
//Customise Name
//create profile on init from template.
//Allow to save game and load up again
//magic: mana, spells, etc
//check class when equipping stuff
//XP and levelup function
//add level requirement to equiping
//character creation
//classes: fighter, priest, wizard

add effects, i.e. poisen over time or temp stat boosts
mass effect spells
spell scrolls
container traps function
out of combat casting
Searchable corpses, levelled lists loot
have a max health check (check template) that should be a limit for heals
persistant bonuses from equipped items (e.g. sword of +2 strength or dagger of +5 damage)
introduce concept of turns (both in and out of combat)



Fixup UI



VERSION 2: Angular 4 + typescript

Lambda




CASTING LOGIC:

use cases:

in combat:

cast <damage spell> on <target>
cast <mob effect spell> on <target>
cast <mass damage spell>
cast <mob mass effect spell>
cast <self effect spell>

effect: damage, heal, buff, debuff
target: mob, all, self
duration: number of rounds for effect
cooldown: number of rounds until recast



out of combat:
cast <self effect spell>


examples (OOC)

cast hearth heal
<actionString> <userInputString>

if (magic[userInputString].target === self {
    apply effect to self
} else {
    consolePush("You cant cast that out of combat");
}





In Combat:

regex: <cast> <spell> on <target>

if (magic[spell].target === self) {
    apply effect to self
} else if (magic[spell].target === mob) {
    apply effect to <target>
} else if (magic[spell].target === all) {
    apply effect to all mobs
}




OVER TIME CASTING:

cast the spell
remember the spell
check to see if duration for spell is active
if active, recast the spell



timeEffect = KEY:<counter value when cast> : VALUE:<counter value when expires>

effectStore = <spell name> : <counter value when cast>


iterate through effectstore:
    if effectstore.value = timeEffect.key
        cast effectStore <spell name>


if (character.spells.indexOf(castSpell) > -1)


                (BELOW PASSES TIMEEFFECT AND RETURNS :VALUE)
                for (var key in timeEffect) {
                    console.log(timeEffect[key]);
                }



was spell : counter    <effectStoreKey> : <effectStoreValue>

new: spell : [counter, amount]












